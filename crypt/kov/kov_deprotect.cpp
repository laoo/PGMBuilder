// KOV deprotection written by IQ_132

#include <algorithm>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kov_asm.h"

static const unsigned char kov_tab[256] = {
	0x17, 0x1c, 0xe3, 0x02, 0x62, 0x59, 0x97, 0x4a, 0x67, 0x4d, 0x1f, 0x11, 0x76, 0x64, 0xc1, 0xe1,
	0xd2, 0x41, 0x9f, 0xfd, 0xfa, 0x04, 0xfe, 0xab, 0x89, 0xeb, 0xc0, 0xf5, 0xac, 0x2b, 0x64, 0x22,
	0x90, 0x7d, 0x88, 0xc5, 0x8c, 0xe0, 0xd9, 0x70, 0x3c, 0xf4, 0x7d, 0x31, 0x1c, 0xca, 0xe2, 0xf1,
	0x31, 0x82, 0x86, 0xb1, 0x55, 0x95, 0x77, 0x01, 0x77, 0x3b, 0xab, 0xe6, 0x88, 0xef, 0x77, 0x11,
	0x56, 0x01, 0xac, 0x55, 0xf7, 0x6d, 0x9b, 0x6d, 0x92, 0x14, 0x23, 0xae, 0x4b, 0x80, 0xae, 0x6a,
	0x43, 0xcc, 0x35, 0xfe, 0xa1, 0x0d, 0xb3, 0x21, 0x4e, 0x4c, 0x99, 0x80, 0xc2, 0x3d, 0xce, 0x46,
	0x9b, 0x5d, 0x68, 0x75, 0xfe, 0x1e, 0x25, 0x41, 0x24, 0xa0, 0x79, 0xfd, 0xb5, 0x67, 0x93, 0x07,
	0x3a, 0x78, 0x24, 0x64, 0xe1, 0xa3, 0x62, 0x75, 0x38, 0x65, 0x8a, 0xbf, 0xf9, 0x7c, 0x00, 0xa0,
	0x6d, 0xdb, 0x1f, 0x80, 0x37, 0x37, 0x8e, 0x97, 0x1a, 0x45, 0x61, 0x0e, 0x10, 0x24, 0x8a, 0x27,
	0xf2, 0x44, 0x91, 0x3e, 0x62, 0x44, 0xc5, 0x55, 0xe6, 0x8e, 0x5a, 0x25, 0x8a, 0x90, 0x25, 0x74,
	0xa0, 0x95, 0x33, 0xf7, 0x51, 0xce, 0xe4, 0xa0, 0x13, 0xcf, 0x33, 0x1e, 0x59, 0x5b, 0xec, 0x42,
	0xc5, 0xb8, 0xe4, 0xc5, 0x71, 0x38, 0xc5, 0x6b, 0x8d, 0x1d, 0x84, 0xf8, 0x4e, 0x21, 0x6d, 0xdc,
	0x2c, 0xf1, 0xae, 0xad, 0x19, 0xc5, 0xed, 0x8e, 0x36, 0xb5, 0x81, 0x94, 0xfe, 0x62, 0x3a, 0xe8,
	0xc9, 0x95, 0x84, 0xbd, 0x65, 0x15, 0x16, 0x15, 0xd2, 0xe7, 0x16, 0xd7, 0x9c, 0xd3, 0xd2, 0x66,
	0xf6, 0x46, 0xe3, 0x32, 0x62, 0x51, 0x86, 0x4a, 0x67, 0xcc, 0x4d, 0xea, 0x37, 0x45, 0xd5, 0xa6,
	0x80, 0xe6, 0xba, 0xb3, 0x08, 0xd8, 0x30, 0x5b, 0x5f, 0xf2, 0x5a, 0xfb, 0x63, 0xb0, 0xa4, 0x41
};

static void pgm_decrypt_kov( std::span<uint8_t> rom )
{
	int i;
	unsigned short *src = (unsigned short *)rom.data();

	for (i = 0; i < 0x400000/2; i++) {
		unsigned short x = src[i];

		if ((i & 0x040480) != 0x000080) x ^= 0x0001;
		if ((i & 0x004008) == 0x004008) x ^= 0x0002;
		if ((i & 0x000030) == 0x000010 && (i & 0x180000) != 0x080000) x ^= 0x0004;
		if ((i & 0x000242) != 0x000042) x ^= 0x0008;
		if ((i & 0x008100) == 0x008000) x ^= 0x0010;
		if ((i & 0x022004) != 0x000004) x ^= 0x0020;
		if ((i & 0x011800) != 0x010000) x ^= 0x0040;
		if ((i & 0x004820) == 0x004820) x ^= 0x0080;

		x ^= kov_tab[i & 0xff] << 8;

		src[i] = x;
	}
}

#define JSR_ADDR	(0x4f1000)
#define RESPONSE	(0x81e080)

static void kov_patch( std::span<uint8_t> src )
{
	int i, j, k;
	unsigned short *mem16 = (unsigned short*)src.data();

	std::copy_n( kov_asm_bin, kov_asm_bin_len, src.data() + 0x3f1000 );

	for (i = 0; i < 0x1000; i+=2) {
		int t = src[0x3f1000 + i];
		src[0x3f1000 + i] = src[0x3f1001 + i];
		src[0x3f1001 + i] = t;
	}

	unsigned char ram_string[16] = {
		'I', 'G', 'S', 'P', 'G', 'M', 0, 0, 0, 0/*REGION*/, 'C', 'H', 'I', 'N', 'A', 0
	};

	ram_string[9] = 5; // region

	for (i = 0; i < 16; i++) src[0x3f0000+(i ^ 1)] = ram_string[i];
	
	unsigned int address_value0 = 0;
	unsigned int address_value1 = 0;

	for (i = 0; i < 0x380000/2; i++)
	{
		// modify asic calls in the form of move.w Dx, $50000x
		if (mem16[i] == 0x33c0 && mem16[i+1] == 0x50)
		{
			if (mem16[i+2] == 0)
			{
				// disable writing data, use ram address directly in protection routine
				mem16[i] = mem16[i+1] = mem16[i+2] = 0x4e71; // nop
				
				if (mem16[i-3] == 0x33c0 && mem16[i-2] == 0x81)
				{
					address_value1 = (mem16[i-2] << 16) | mem16[i-1];
				}
			}
			else if (mem16[i+2] == 2)
			{
				// handle command
				mem16[i] = 0x4eb9;
				mem16[i+1] = JSR_ADDR >> 16;
				mem16[i+2] = JSR_ADDR & 0xffff;

				if (mem16[i-3] == 0x33c0 && mem16[i-2] == 0x81)
				{
					address_value0 = (mem16[i-2] << 16) | mem16[i-1];
				}
			}

			continue;
		}

		// modify asic calls in the form of move.w $815bcx, $50000x
		if (mem16[i] == 0x33f9 && mem16[i+1] == 0x81 && mem16[i+3] == 0x50)
		{
			if (/*mem16[i+2] == 0x5bc6 && */mem16[i+4] == 0)
			{
				// disable writing data, use ram address directly in protection routine
				mem16[i] = mem16[i+1] = mem16[i+2] = mem16[i+3] = mem16[i+4] = 0x4e71; // nop
			}
			else if (/*mem16[i+2] == 0x5bc4 && */mem16[i+4] == 2)
			{
				// handle command
				mem16[i] = 0x4eb9;
				mem16[i+1] = JSR_ADDR >> 16;
				mem16[i+2] = JSR_ADDR & 0xffff;
				mem16[i+3] = mem16[i+4] = 0x4e71;
			}

			continue;
		}

		// modify asic reads
		if ((mem16[i] & 0xf1ff) == 0x3039 && mem16[i+1] == 0x50 && mem16[i+2] <= 2)
		{
			mem16[i+1] = RESPONSE >> 16;
			mem16[i+2] = (RESPONSE + (~mem16[i+2] & 2)) & 0xffff; // top and bottom words swapped

			continue;
		}
		
		// remove unknown asic offset, clr.w   $500004.l
		if (mem16[i] == 0x4279 && mem16[i+1] == 0x50 && mem16[i+2] == 0x0004)
		{
			mem16[i] = mem16[i+1] = mem16[i+2] = 0x4e71;
		}
	}

	// these are the addresses of the "command" and "value", put them here and use them in the protection routine
	// this makes the routine compatible w/kovplus
	mem16[0x3f0ff8/2] = address_value0 >> 16;
	mem16[0x3f0ffa/2] = address_value0 & 0xffff;
	mem16[0x3f0ffc/2] = address_value1 >> 16;
	mem16[0x3f0ffe/2] = address_value1 & 0xffff;

	// remove "tamper" protection
	// these verify the asic calls are not modified
	for (i = 0; i < 0x380000/2; i++)
	{
		// the 68k uses obfuscated data to perform these checks
		// usually in the form move.l	#$xxxxxxxx, (-$xx,Ax)
		// it will then modify this data in registers to be usable
		// check for this
		if (mem16[i] == 0x2d7c && mem16[i+3] >= 0xff00)
		{
			int counter = 1;

			for (j = 4; j < 32; j++)
			{
				if (mem16[i+j] == 0x2d7c && mem16[i+j+3] >= 0xff00)
				{
					counter++;
				}
			}

			if (counter >= 3)
			{
				for (k = 0; k < 128; k++)
				{
					// tamper protection calls have a beq followed immediately by a jsr
					if ((mem16[i+k] & 0xff00) == 0x6700 && mem16[i+k+1] == 0x4eb9)
					{
						for (j = 1; j < 10; j++)
						{
							// further back, it also has a bne
							// if all of the conditions are correct, patch the above beq and this bne
							if ((mem16[i+k-j] & 0xff00) == 0x6600)
							{
								mem16[i+k-j]   = 0x4e71; 			// bne -> nop
								mem16[i+k]     = 0x6006; 			// beq -> bra

								i = (i+k-j)+1;
								k = 1000;
								break;
							}
						}
					}
				}
			}
		}
	}
}

namespace crypt
{

void kov( std::span<uint8_t> rom )
{
	pgm_decrypt_kov( rom );
	kov_patch( rom );
}

}
